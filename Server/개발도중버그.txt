레벨을 cpp로 만들어야함 . ->클라에게 요청


INetwork 순수가상함수가 Recv에 걸려있어서 버그를 발생시킴. 

//

room에 필요한것들.
player정보, room상태(게임중인지, 대기중인지), 
클래스로 비교? 


내꺼컴터기준 서버 1개당 500명정도 60fps로 보내도 쾌적하게 게임 가능 



https://www.youtube.com/watch?v=DCA-b-9j08o

https://www.inflearn.com/questions/853438/%EC%9D%B4%EB%8F%99-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%A4%91%EC%97%90%EC%84%9C-%EB%94%9C%EB%A0%88%EC%9D%B4%ED%9B%84-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%B2%98%EB%A6%AC

2023-09-22
배포 흠,,

아이디 패스워드 20자 

과 끼리 경쟁
1등학과 보상/ 꼴지학과 벌칙
닉네임 옆에 칭호를 1등팀에서 꼴지를 정할 수 있게 DB에 칭호 올리기


토-일 파트별 미팅

월-> 데모플레이 가능하게

화-> 매치메이킹

장애물동기화는 조금 나중에 -> ; 

추석연휴 ->



티어가 기본 -> 위쪽티어가 숫자가 적어야함.
위쪽티어가 시간 지날때마다 아래티어에 들어갈 수 있도록.

검사는 위쪽부터 해서 최대한 위쪽까지 붙을 수 있게, 

4명 꼭 8명 아니더라도 출발해야되니까 감안해서 코딩하기.

S-F간 매칭 성사를 할 수 있게 할지 말지

티어가 낮은데 mmr이 높으면 윗쪽티어에 넣기


최소한 Lobby에서 넘어 올 때 인원들이 같은 방에서 하는지는 알아야함. 정보를 받아야함. ->로비서버 요청 
//

------------
현재 room에 들어가는 구조를 Lobby서버에서 받는 packet을 기반으로 해놓았음.
이유: 게임서버에서 room Num을 정해줄 경우 두개의 방이 동시에 켜져야 할 때, 즉 16명이 게임서버로 우르르 쏟아지면 누가 누구랑 같이해야 되는지 구분이 안됨. 그렇기에 로비에서 같은 방에 들어갈 애들은 구분을 해줘야 함.

 방 id는 0~MAX_ROOM 으로 해주면 됨./

로비에서 정해야될게 / 게임 서버 id , 방 id /


Protocol.h <--- 이거 말고



ServerProtocol.h <-- 서버만 쓰는거 만들기.

서버와 서버간 연동 -> 토 X/ 일요일밤 19~22 <- 이때 안됨. 

4~8명

로비서버가 너무많은 데이터를 가지고 있기는 부적절
로비서버가 가지고있는데이터를 게임서버로 옮기는건 OK But 게임서버에서 "만" 필요한건 로비에 굳이 저장하지않고
게임서버가 알아서 DB에서 따로빼온다.

로비: 
클라에서 id 비번을 로비로 보내면
db에서 id비번이 같은 놈의 unique id를 빼서 로비로 보내줌.

db에서 비번저장하는거 일단은 문자열로 하는데 배포 전에는 token식으로 암호화 << 해야 될 듯?


게임서버에서 필요한정보가 : 유저 닉네임, 과, 스킨, 돈, 랭크 


----------------------------------------------------
월요일까지 일정

db연결
----------------------
1. 서버간 통신 연결 - 저희 셋이 다 해야되는거
2. 로그인 구현 - 플레이어 데이터 <- 테스트해서 잘되기만 하면 패킷만 보내면 끝이니까 
3. 로비에서 start누르면 게임서버로 넘어가게끔. <- 일단 UI가 필요함. 그거 Button이 CPP로 되어있어야함. 

1. 서버간 통신 연결 (DB-로비//로비-게임// 로비-클라) (서버 모두)
2. 로그인 쿼리구현(한성재)
3. 로비서버 로그인 기능 구현 (한성재)
4. 로비서버에서 Start UI눌러서 게임서버로 게임 진행 기능 구현  (김경욱)


2. 애니메이션 연동 - 내가 할 거





서버 - 서버 연결은 // 클라하고 서버가 구분이 되어야 함.

--------------------------------
그런데 왜 클라랑 서버랑 분리를 하나?
-> 클라이언트에서 해킹을하여서 패킷을 서버걸로 보내도 무시할 수 있게

--------------------------------

제가 예전에 했던 방식은

전제: 게임서버가 로비서버로 연결을 시도함. (로비서버는 게임서버의 연결을 받음)

------------------------------
1. 내가 예전에 했던 방식.
로비서버는 게임서버를 일단은 클라이언트로 인식해서 Session으로 받음 일단

그리고 게임서버는 자신이 서버라는거를 알리기 위해서 새로운 패킷을 보냄.

그럼 로비서버는 그 패킷을 받아서 게임서버를 클라이언트가아닌 서버로 구별해서 받음


------------------------------
2. 이번에 새로 해보고싶은 방식
게임서버가 애초에 로비서버로 Connect를 할 때, 특정한 비트를 보내줌.

로비서버는 Accept를 받을때 이미 서버랑 클라랑 다른지를 앎.

그럼 서버가 자신이 서버라는 패킷을 보낼 필요가 없음.


------------------------------

2.0.13.172

2.0.13.172 << 서버의 로컬 주소 크기
0000 0010 0000 0000 0000 1101 1010 1100

33557932 < 

127.0.0.1 << 클라이언트의 원격 주소

AcceptEx()

WsaAccept() 



https://learn.microsoft.com/ko-kr/windows/win32/api/mswsock/nf-mswsock-acceptex

dwReceiveDataLength에는 입력받을 데이터 바이트 크기인데,
이 바이트에서 서버의 로컬 주소 크기(IPv4기준 4)와 클랑이언트 원격 주소(IPv4기준 4개 ex)127.0.0.1가 포함되지 않아야함

200바이트를 받으면 위 두개 8바이트를 빼서 192바이트까지 받을 수 있는것.


문제점 : 
로비에서 게임서버가 몇개 켜질지 정확히 알아야함.


서버가 1000이라고 치면
클라는 0부터 시작.

mServers[0~999] << 못쓰는놈임. 
key값이 0으로 들어오는얘가 없어서.


memcpy랑 reinterpret_cast랑 방식이 다름.


현재: 겜서버랑 로비랑 연결 완료 

https://snowfleur.tistory.com/116



https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-wsaconnect

로비서버에서도 몇번째 방이 게임중이고 몇번째 방이 free한지 앙라야하니까 

구조:
1.클라이언트가 로비서버로 매칭 패킷을 보냄  -- 완
2.로비서버가 매칭 로직을 돌려서 8명을 만듬  -- 미완
3.로비서버가 게임서버로 n번 방에 들어갈 클라이언트들의 명단(id,uid)을 패킷을 담아 보냄. --(경욱이형)
4.게임서버가 명단(id,uid)을 받고 클라이언트를 받을 준비를 마침 -- 완
5.게임서버가 로비서버로 클라이언트들를 받을 준비가 완료 됐다는 패킷을보냄 -- 완 (경욱이형)
6.로비서버가 게임서버의 n번 방 준비 완료 패킷을 받고, 클라이언트들에게 게임서버로 가라는 패킷을 보냄.-- 완 (경욱이형)
7.클라이언트는 로비서버에서 보낸 패킷을 받고, 해당 게임서버로 connect, 자신의 정보 id, uid를 게임서버로 보냄. --
8.게임서버는 로비서버에서 받은 명단(id,uid)과 클라이언트가 보낸 명단(id,uid)를 비교, 구분하여 접속완료 패킷을 보냄.
----- 안정성및 보안을 위한 코드임. ----




보안성을 없앤 구조

1.클라가 로비서버로 매칭 패킷 보냄.
2.로비서버가 매칭 로직 돌려서 8명 만듬
3.로비서버가 클라이언트에게 n번 방으로 가라는 패킷을 보냄
4.클라이언트는 로비서버에게서 패킷을 받고 게임서버로 connect, 자신이 몇번 방으로 가야할 지 보냄
5.게임서버는 받고 접속완료 패킷을 보냄.

----
이렇게 하면 일단 클라에서 패킷조작시 난입할 수 있음 보안적으로 좋지않음

보안성을 챙긴 구조

1.클라이언트가 로비서버로 매칭 패킷을 보냄
2.로비서버가 매칭 로직을 돌려서 8명을 만듬
3.로비서버가 게임서버로 n번 방에 들어갈 클라이언트들의 명단(id,uid)을 패킷을 담아 보냄.
4.로비서버가 클라이언트들에게 게임서버로 가라는 패킷을 보냄.
5-1.게임서버가 명단(id,uidd)을 받고 클라이언트를 받을 준비를 마침
5-1.클라이언트는 로비서버에서 보낸 패킷을 받고, 해당 게임서버로 connect, 자신의 정보 id,uid를 게임서버로 보냄.
6.게임서버는 로비서버에서 받은 명단(id,uid)과 클라이언트가 보낸 명단(id,uid)를 비교, 구분하여 접속완료 패킷을 보냄.

보안성은 챙겼으나 5-1중 무엇이 먼저 실행 되는지 보장할 수 없음. (패킷이 밀린다거나, 스레드가 바쁘다거나의 이유로)
물론 당장에 네트워크가 밀릴 일이 없으니 순서대로 오겠지만 나중에 서버가 점점 바빠진다면 문제가 될 코드임.
그래서 미리 안정성도 신경써서 설계함.





1. 로비서버와 디비서버 연결할 때, 특정패킷 보내서 알맞은 서버인지 확인하는 작업(한성재)




서버
 
다이브/점프 이동 동기화 및 보간 필요여부 -> 수민 
공통 장애물 동기화 - 혹시 안해도 될까? -> 해야 함. -> 수민 

클라-서버간에 핑테스트 하고 그 차이만큼 ms씩 미뤄서 동시에닫히게 << 

todo
 
골인 판정 패킷 수용 및 처리				-> 수민
로그인이 되었다가 안되었다가 간헐적으로 됨		-> ??????? 

회원 가입
클라쪽에서 패킷 send부분 짜고 로비에서 받고, 로비에서 디비로 보내고. -> 성재형
비밀번호 암호화						-> 성재형(테이블이 바뀔 수 있음 스키마 업데이트 필요)

1.	매치메이킹을 해서 인원을 모으는 작업(리스트같은데에 인원 집어넣기)(경욱이형의 매치메이킹 로직)
1-1.	인원을 모았을 때, 일정 시간동안 인원이 안 모이면 안 모인 채로 게임 시작(일정 시간의 기획 필요)
1-2.	매치도중 매칭 취소를 눌렀을 때, 대기열에서 뺄 수 있게
1-3.	매치도중 연결이 끊겼을 때, 대기열에서 뺄 수 있게
-> 경욱이형 

뒤로가기 버튼 << 기능 구현 하기.	-> 수민 경욱이형
					-> 경욱이형
플레이 로직 동기화(문 열리고 닫히고)			-> 수민
클라 선작업
딜레이가 될 예정


로그인 구조
1.로비서버랑 연결
2. 연결이 됐을 때, 로그인 가능 (연결이 안됏으면 로그인 불가) -> 경욱이형


기획한테 물어보기.
게임서버가 플레이어의 학점을 알고 있기 때문에
승패 했을때 등수에 따라서 학점 계산(가중치 등등 다 고려한)을 하고 로비서버로 학점을 보내줌.



//보류 로비서버에서 학점 결과를 알려주어야함. 

결과창이 게임서버에서 하는지 로비에서 하는지 딱 정해야함 . -> 정해짐





매치메이킹은 구현 하되, mmr고려 및 결과값 계산은 추석 이후.
비유)일반게임은 구현, 랭겜은 이후

고려해야 할 것 -> 게임서버에서 튕겼다가 재접속<< 할 일에만 넣어놓고 추석 이후.


다이브/점프 이동 동기화 및 보간 필요여부 -> 수민 
골인 판정 패킷 수용 및 처리				-> 수민
게임 종료관련 로직 처리					-> 수민
게임 종료 후 로비로 되돌아가기				-> 수민
플레이 로직 동기화(문 열리고 닫히고)			-> 수민

뒤로가기 버튼 기능구현 -> 경욱이형
매치메이킹
1.	매치메이킹을 해서 인원을 모으는 작업(리스트같은데에 인원 집어넣기)(경욱이형의 매치메이킹 로직)-> 경욱이형 
1-1.	인원을 모았을 때, 일정 시간동안 인원이 안 모이면 안 모인 채로 게임 시작(일정 시간의 기획 필요)-> 경욱이형 
1-2.	매치도중 매칭 취소를 눌렀을 때, 대기열에서 뺄 수 있게			-> 경욱이형 
1-3.	매치도중 연결이 끊겼을 때, 대기열에서 뺄 수 있게			-> 경욱이형 

회원 가입. -> 성재형
비밀번호 암호화	-> 성재형
중복 로그인 체크 -> 성재형











최초 1등한 사람 발생시 20초 기다렸다가 끝 -> room에 있는 플레이어에게 broadcast

캐릭터 visible 끄기,or 아공간으로 보내기

부딪히면 부딪힌 패킷을 서버로 보냄
서버는 몇등인지 판단하고-> 1등일시 room내 모든 유저에게 broadcast -> 타임아웃 카운트 0이 됨
0이되는 순간에 클라에서 독단적으로 멈출것인지 그럼 0.1 <<이 남아서 움직잀 ㅜ 있었음
그래서 도착지점에 골인을함
하지만 서버에서는 이미 끝남 << 그럼 상태패킷을 락을 걸어야하나? 그럼 락을 로직스레드에서 걸까? 그럼 락이너무많이걸려서 성능이 안좋을거같은데 ? <<< 
도착했을때 클라에서 패킷 보내주는 공간에서 만 락을 걸면 락을 최소화 할 수 있지않을까 < 라고 결론이 남. 

클라에서 돌아가는 타임카운트는 겉값이고
서버에서 0초가되면 다시 패킷을 보내줘서 완전히 끝낸다.

클라에서 판단을 하면
골인을했을때 < 골인 이펙트가 나온다 ? 이걸 클라에서 독단적으로 계산을 해버리면 

골인했을때 뜨는 이펙트나 UI < 어떤식으로 할건지. 

골인하면 일단 안뜨고 20초가 끝나거나 다 완주를 해서 게임이 끝나면 성공 실패를 띄워준다. 

클라 -> 오버랩되면 패킷보내기.
A클라가 골인을 함
A클라 -> 캐릭터 비지블 끄기 시점 다른사람으로 넘어가기
B클라 -> A클라가 도착했다는 패킷 받아서 [A클라 비지블및 콜리전 끄기](함수화 해놓으면)
모든클라 -> 누군가 1등을 도착했다는 패킷을 받아서 [타임아웃 카운트 올리기](함수화) TimerAcitve();


20초 이후
모든클라 -> 서버에서 받은 패킷으로 [성공 or 리타이어 결과 띄워주기] 함수화
모든클라 -> 결과에서 확인 누르면 로비로 넘어가기.




등수 -> 기획이랑 얘기
리타이어면 가중치 0 
리타이어를 넣는걸로 못들어오면 리타이어





필요한 패킷
클라가 게임한테 도착했다 보내는 패킷
클라가 게임한테 게임이 끝나서 나간다고 보내는 패킷

게임이 클라한테 누군가 도착했다 보내는 패킷
게임이 클라한테 카운트다운 시작하라는 패킷
게임이 클라한테 게임이 끝났다는 패킷


server.cpp의 EV_MATCH_UP 519Line에 mMatchListLowTier가 0일때 pop_front를 하려 해서 서버가 터짐. < 경욱이형 버그.


사실 ping구하는것도 평균값을 구해서 근사치로 전달하는게 좀 더 안정적임.

----------해야될 것---------------
점프 동기화
다이빙 동기화




uid랑 name이랑 비교구분해서 검증작업 하기  


"Client ID랑 Room ID랑 Db UID 구분하기 " 

1. 매칭 취소 버튼 필요함. << 

2. 서버 연결 끊겼을때, 서버와 연결 끊겼습니다 UI필요함 << 

3. 문 <<milliseconds (1초는 1000)단위로 받아서 그 시간 안에 닫히게 해야함. 3024 < 3.024초 뒤에 닫히게끔 설계를 해야합니다.(문이 폐 되는 시간)

4. 도착했을때 성공,실패 보여지는건 어차피 겉값이니까 클라에서 판정하는게 더 좋아보임.(패킷에 데이터를 낭비하고 싶지 않음)

playerdisable 함수가 GoalArea에 있어서 Network클래스에서 호출을 못함.(GoalArea 객체를 Network클래스에서 관리해야 함수 호출가능)
1. 함수를 static으로 만들던가, 
2. Character 클래스에 함수를 정의해놓으면 Thanks


UI에 도착한 인원 +1 Update 해주는 함수 필요.



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
부딪히면 부딪힌 패킷을 서버로 보냄
서버는 몇등인지 판단하고-> 1등일시 room내 모든 유저에게 broadcast -> 타임아웃 카운트 0이 됨
0이되는 순간에 클라에서 독단적으로 멈출것인지 그럼 0.1 <<이 남아서 움직잀 ㅜ 있었음
그래서 도착지점에 골인을함
하지만 서버에서는 이미 끝남 << 그럼 상태패킷을 락을 걸어야하나? 그럼 락을 로직스레드에서 걸까? 그럼 락이너무많이걸려서 성능이 안좋을거같은데 ? <<< 
도착했을때 클라에서 패킷 보내주는 공간에서 만 락을 걸면 락을 최소화 할 수 있지않을까 < 라고 결론이 남. 

클라에서 돌아가는 타임카운트는 겉값이고
서버에서 0초가되면 다시 패킷을 보내줘서 완전히 끝낸다.


예전에 얘기 했던 내용인데, 생각해보니 그냥 서버에서 End패킷 보내면 서버에서 상태 한 번 바꾸고(딱 한 번 불리는 함수 만들어놓음)
이후로 오는 GOAL패킷은 걍 싹다 무시하면 될 듯? (서버단에서 처리하면 클라에서 독단적으로 처리해도 됨)
이게 좀 더 개발에 있어서 신경을 덜 써도 되는 방향인것같음. << 회의때 얘기.



openlevel해서 레벨이 넘어간단 말임? ->> 이때 렉이 심하게 걸림. object갖고오는것도 그렇고 언리얼내에서


서버가 플레이어 8명이 다 들어오면 패킷을한번 더 보냄.
 

클라 8명이 로비서버에서 매칭을 함.
로비서버가 매칭을 잡고 이 8명의 정보를 겜서버로 보냄
겜서버가 8명을 룸하나에 넣고 로비서버한테 준비됐다고 보냄
로비서버가 클라들한테 겜서버로 가세요~

클라이언트의 레벨이 lobby 에서 level1.ver1로 넘어감 
클라가 게임서버에 연결을 시도함. (로딩이 끝난 상태)

겜서버가 클라 8명을 다 받으면 [이때부터 타이머 돌아가게 끔] -> 이때부터 몇초 ?

3 2 1 시작 -> 

클라 8명이 다들어옴.

서버가 패킷을 한번 보내고(클라입장에서는 object동기화 타이밍, 321 UI 띄우는 타이밍 도 되는)
 타이머를 잼(4초)

클라에서 패킷을 받고 여기서 3 2 1 go(5초가 걸림)










게임 시작까지 4초대기. 
매번 동기화 맞추는것보단 시작할때 한번. 


8

문 부서지는거,
땅 밟으면 깨지는거(몇초 잇다가 다시 생겨야함),
그랩



시작동기화 패킷 설계	05일 13시 -수
부서지는 문		05일 24시 -성
부서지는 발판		06일 24시 -성
로비에서 방 여러개 사용할 수 있게 설계	06일 24시 -경
mmr설계					07일 24시 -경
이동동기화		08일 24시 -수
게임서버 재사용		-수






3명부터 로비에서 접속이 안됨.



빈 껍데기 캐릭터가 obj에 맞아서 튕기면 Velocity가 변함. 근데 지금 껍데기캐릭은 물리엔진 처리를 안해서 Velocity가 겁나 떨림.

어차피 장애물에 맞는거는 본 클라에서 판단하는거니까 껍데기캐릭터는 collision을 분리해주면 좋겠음.
Collision 채널을 만들어서 장애물을 따로 관리하던가, 아니면 껍덱쓰를 따로 관리하던가 해야할듯.



(내기준)
나	껍데기	포함
0	0	1 	-> 1
1	0	1	-> 0
0	0	1	-> 1
1	0	1	-> 0

(껍데기기준)
나	껍데기
0	0	0	-> 1 
1	0	0	-> 1
0	1	0	-> 0
1	1	0	-> 0
0	0	1	-> 1
1	0	1	-> 1
0	1	1	-> 0
0	1	1	-> 0










포세스가 1일 경우 -> 
is air에만 영향을 받고 
network에는 영향을 안받아야함 

포세스가 0일 경우 ->
is air에는 영향을 안받고
network에는 영향을 받아야함.

1. 서버에서 object 좌표를 다 알고 (txt파일같은거로)
서버에서 생성하고, 생성하면 클라에 보냄. 그럼 클라가 이 좌표및 netid 받아서 이걸 기반으로 생성을 함 [Best]
-> 안됨

2. 클라에서 독자적으로 Net ID를 설정을 함.



1. 서버 김경욱 mmr설정 보다, 로비에서 방 여러개 사용할 수 있게 하는게 더 시급하다고 생각하여 작업 내용 수정
로비에서 방 여러개 사용할 수 있게 설계	06일 24시 -경
mmr설계					07일 24시 -경

2. 서버 한성재 현재 DB작업이 끝나 할 일이 없어서 이수민의 부서지는 문, 부서지는 발판 작업을 양도 (Jira에 적용 시켜놓았음)

3[핵심]. 현재 UI작업이 더뎌져서 서버작업이 멈춰있는 상태 (캐릭터 생성, 결과창UI ,로비 UI에서 학점및 포인트 띄우기, 로그아웃 등등)
-> 클라쪽에서 UI작업이 한명뿐이라 더뎌지는거면 UI쪽에 좀 더 시간을 쏟아부어야 하는게 아닌가? 잡기는 나중에 추가해도 되는 콘텐츠이지만 UI는 안만들어지면 게임답지가 않을것 같다는 개인적인 의견

1,2번은 작업내용 관련이고 3번은 pm님이 잘 말씀해주시면 감사하겠습니다.




결과값 보내는 패킷 만들기 < 





샌드패킷 몰려온거 처리하다가 두번 디스커넥되면 난리남.


8명대기일때 6명신청중이어도 4명만 모아서감
방 최대인원 3명설정하면 터짐. 










게임서버에서 로비서버로 패킷이 안보내지는 버그 GL_ROOM_READY패킷이 안보내지는 것 수정
결과창 UI랑 로비 UI 연결
결과창 UI 게임도중에 보이는게 아니라 로비로 나가서 보이게끔 설계
회원가입 성/실패, 로그인 성/실패 패킷 로비에서 담아서 클라에게 보내기 --구조상 불가

버그수정 << 







방 리셋 되는지 (완) , 방 2개 동시에 돌아가는지(완).










한글이 1자당 3byte를 사용해서 maxlength 바꿈.

3.5이상과 3.5미만으로 나누는데 그럼 3.5이상이 4명이 안될때가 반드시 한 번은 존재하는데 이때 처리를 어케할건지. 

로비서버 Room클래스에 RoomLevel 작성. 



3.5 이상/미만 인데, 동접이 별로 없을거같으니까 이거 없애버려도됨. 경욱이형이 말한상위권 매칭이 안잡히면 low에 넣고 돌리는거 기술적으로 해봐도 좋고.


나중에 출시하고 디비 보면서 3.5기준 바꿔야할수도 있으니까 바꾸기 쉽게 3.5 상수 말고 constexpr 값으로 수정하는것을 요청.




mysql이 근본적으로 없으면 mysql헤더없다고 빨간줄

ID/비밀번호에 한글 및 특수문자 입력시 방지코드 QA
매칭 취소 QA(디버깅 메세지가 뜨면 좋을듯)
게임도중 나가기 QA/ 최대한 게임서버와 로비서버를 터트리는것을 목적으로 QA


1. strcpy_s 함수 잘못 쓰고 있어서 터지고있었음.
2. 로비레벨아니고 레벨에서 시작할 시, roomSyncID -1이라 터지는거 무시

DB sSocket.cpp 에서 memcpy 인자 sizeof 잘못써서터지던 버그 수정.



자기캐릭터가 옷이 안보임



다중이 문제

자꾸 이상하게 끊겼을때 문제

로비서버에서 아무패킷이나 보내줘야하는거 추가해야함.
ID/비밀번호에 한글 및 특수문자 입력시 방지코드


로그인/ 매칭 요청/ 인게임에서 랜덤무브 << 크게보면 3개 

로그인(로그인 요청, 응답)
매칭요청(매칭응답 받기, 게임서버로 연결 시도, 게임서버 login ok 패킷 받고, 게임서버로 다시 ack 패킷보내기)


중복로그인 연결 끊는것. 

경욱 - 중복로그인 관련해서 필요한 작업.
-> 로그인시도 할 때, 로그인이 안되고 클라 접속연결이 끊기는 이슈 <<<
(사람들이 이거때문에 로그인이 안되는거라고 착각함 사실 로비에서 연결끊은건데)
재현도 해보시는걸로


->디버그 메세지좀,,, 로그인성공 ! < ss 로그인성공 

성재 - 더미클라 제작. 




테스트 일정 
오후 20시~ 23시 << 기본으로잡는데

<진행도>
테스트 하다가 서버or 클라가 터진다.
그럼 고치기전까지 테스트 stop (자기 할거 하면 됨)
그리고 다시 고쳐지면 그때 다시 test
<목적>
근데 test의 목적 << 클라 or 서버를 터트리는걸 목적으로 테스트 


학과랭킹 << 기준이 뭐임 ? CBT 전까지 개발이 필요한거임?


CBT전까지 개발이 필요함. 확정 아님. 안함.
랭킹 6개까지 보여져야함.
(포인트 합산) 리타이어는 1점. 리타이어는 포인트 표를 안따라가고 무조건 1점.
리셋이 필요함. 끝까지 남아잇는애는 1점. 탈주맨은 0점. 



UI 적인 문제를 이야기했음.

-----------
오늘테스트 봐야할 것.
result ui에 점수랑 포인트 표기가 왜 안되는지.

클라이언트 자신이 점수랑 포인트를 이제 가지고있어야함.


자기 옷 바뀌는지 확인

--------------------
해야될 것.
방에 아무도 안남아있으면 자동으로 방 리셋하기 





게임끝날때 3 크게뜨는거 수정해야하고
맵 이름 한국어로 넣어서 깨지는거 수정해야하고


6레벨 발판이 무한으로 안나옴

--------------------------------------------
출시까지 개발 X 버그만 잡기.


생성위치 4열2행 . . . .  만들기
                . . . . 


다 도착하면 즉시 끝나게 만들고


END 패킷에서 RESET을 10초뒤에 부름
i ) 사람이 다 빠져나감(정상적)
ii )  사람이 다 빠져나가지 못함( 비 정상적)

i -> 사람이 다 빠져나가면 reset을 함. 
그와 동시에 로비에서 또 방을 세팅을 해줌.
근데 뒤에 부른 reset 패킷이 10초뒤에 와서 그 방을 리셋함 (문제 발생)
-> 시간을 넣어서 마지막으로 리셋한 시간을 저장하고, 이거보다 이전에 리셋패킷이 온다면 그냥 무시해야함. < 해결

내일 만들기

-> 생각해보니 ST_CLOSED 상태일때만 리셋을 해줌.
다시 방이 만들어지고 리셋하라고 해봤자, ST_INGAME 이든 뭐든 CLOSED는 아니라서 리셋진행이 안됨.
이미 어제 해결한 문제였음.







--------------
10 11 수민 해야할거
-> 방 reset 구조 윗 방법대로 설정하기.
retire랑 튕겼을때 구분해서 패킷 주기.
생성위치 4열2행으로 만들기.
다 도착하면 즉시 끝나게 만들기.

Z로 90도 돌려야하고,
뒤로 160 밀고 옆으로는 160씩 간격 띄우게





--------------------


방이 리셋되는 코드 가 게임이 시작되고 다시 불리는데, 이때 


0번방에 0  1 2 3 플레이어가 있었음. 나감 (게임을 종료함) (20초뒤에 방 리셋을 시작함)
Player ST_FREE로 바뀜
다시 들어옴 0 1 2 3 을 씀
1번방에 들어감 플레이를 함.

20초 뒤

0번방 리셋이 시작됨. 하지만 0번방에 아직 mObject에 0 1 2 3의 정보가 남아있음
1번방에 플레이하고있는 애들을 disconnect And Reset 시켜버림
1번방에 잘 하고있는애들 갑자기 튕김 



로비에서 게임서버로 넘어올때 팅겨서
로비는 4명이라 넘겼는데 실제로 로그인한건 3명임. 






(이게 END패킷을 부름) 
1. 모두가 도착했을때 바로 
2. 모두가 나갔을때 바로
3. 누군가 도착하고 20초 뒤에.

1번에 의해서 100초뒤에 RESET이 불리고
3번에 의해서 120초뒤에 RESET이 불림. 

이 20초사이에 간극에 의해서 20초안에 방이한번리셋이되고, 



리셋이되고 END패킷이 불려야 이 버그가 재현이 되는데 << 


RESET

수정 -> 프레이어가 모두 나가고 END패킷을 바로 보내줘야하는데 RESET급으로 보내고잇었음.


오늘 고친 버그.
Player Remove가 안되어서 ( 범위기반 포문에서 포인터를 빼내고 거기에 nullptr을 넣고있었음 가리키는 곳을 nullptr 시키려면 (auto& p : container)를 했어야함.
그래서 PlayerRemove가 안되는 버그가 있었음.

Room이 최종적으로 Reset될때에는 플레이어가 Room쪽으로 다시 끊는걸 없앰. 이게 있으면 Decrease가 다시 불려서 리셋이 됐는데 또 end가 불려서 cas를 망침.


그리고 로비에서 게임서버로 넘어오는 와중에 팅궈버리면 타이머에서 계속 플레이어를 찾음.이걸 방지하기 위해 100번돌면 리셋함 -> 그럼 이미 있는 플레이어들은 어떡하나요 ?
그건 .. ㅠㅠ;; 내일처리해보자.

Send Room BroadCast에서 이상한 RoomID가 넘어오면 그냥 리턴.
그리고 어차피 object한테 보낼 필요없으니까 0~7까지 보내고 . nullptr일때 break가 아닌 continue를 해줌.


그리고 Room에서 Remove할때도 nullptr일때 break말고 continue로 해줌. break로 하니까 데이터레이스때문에
구멍뚫리는걸 못막음.




















첫번째 트라이 -> 모두가 걍 도착을함 그래서 방이 리셋됨.
그리고 게임이 끝나서 모두가 방에서나감 이때 2를 부름
2에서 GameEnd를 부르고 GameEnd가 true가 됨.

























